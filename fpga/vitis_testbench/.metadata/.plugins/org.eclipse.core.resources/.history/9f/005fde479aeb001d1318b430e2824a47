/*
 * This is an attempt to make a program that reads from the fpga's adc and prints the value to the terminal.
 *
 *
 */

// INCLUDES -------------------------------------------
#include <stdio.h>
#include "xparameters.h"
#include "xil_cache.h"
#include "xintc.h"
#include "xemaclite.h"
#include "xtmrctr.h"
#include "xsysmon.h"
//#include "adc_intc_callback.c"

/********************** GLOBAL VAR DEFINISIONS *******************************/
XSysMon *SysMonInstPtr;
u16 SysMonDeviceId;
u16 SysMonIntrId;

volatile int eos_interrupt; 	/* end of sequence alarm intr */

/********************** PROTOTYPE FUNCITONS *******************************/
static int InitAdc(int Status);
static int StartAdc(int Status);
static void SysMonInterruptHandler(void *CallBackRef);
int SysMonSetupInterruptSystem(XIntc* IntcInstancePtr, XSysMon *SysMonPtr, u16 IntrId);

/*****************************************************/
int main(void)
{
	int Status;
	u16 A0;
	u16 A1;
	u16 A2;
	u16 A3;


	Status = InitAdc(Status);

	Status = StartAdc(Status);


	//extern volatile int eos_interrupt; 	/* end of sequence alarm intr */

	while(1)
	{
		if(eos_interrupt)
		{
			print("Interrupt flag was set, checking adc now");

			/*
			 * Read the ADC converted Data from the data registers.
			 */
			A0 = XSysMon_GetAdcData(SysMonInstPtr, XSM_SEQ_CH_AUX04);
			A1 = XSysMon_GetAdcData(SysMonInstPtr, XSM_SEQ_CH_AUX05);
			A2 = XSysMon_GetAdcData(SysMonInstPtr, XSM_SEQ_CH_AUX06);
			A3 = XSysMon_GetAdcData(SysMonInstPtr, XSM_SEQ_CH_AUX07);

			if(A0)
			{
				xil_printf("Data has been received! :D \r\n "
						"A0 data: %d\r\n", A0);
			}

			eos_interrupt = FALSE;
		}
	}

	/*
	 * Disable global interrupt of System Monitor.
	 */
	XSysMon_IntrGlobalDisable(SysMonInstPtr);

}

/******************** FUNCTIONS **********************/
/*****************************************************/

static int InitAdc(int Status)
{
	static XIntc intc;
	u32 IntrStatus;
	XSysMon_Config *ConfigPtr;

	//Xil_ICacheEnable();
	//Xil_DCacheEnable();

	/*
	 * Initialize the SysMon driver.
	 */
	ConfigPtr = XSysMon_LookupConfig(SysMonDeviceId);
	if (ConfigPtr == NULL) {
		return XST_FAILURE;
	}


	XSysMon_CfgInitialize(SysMonInstPtr, ConfigPtr, ConfigPtr->BaseAddress);

	/*
	 * Setup the interrupt system.
	 */
	Status = SysMonSetupInterruptSystem(&intc,
					    SysMonInstPtr,
					    SysMonIntrId);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Clear any bits set in the Interrupt Status Register.
	 */
	IntrStatus = XSysMon_IntrGetStatus(SysMonInstPtr);
	XSysMon_IntrClear(SysMonInstPtr, IntrStatus);

	return 0;
}

/*****************************************************/
static int StartAdc(int Status)
{
	/*
	 * Enable the following channels in the Sequencer registers:
	 * 	- On-chip Temperature
	 * 	- On-chip VCCAUX supply sensor
	 * 	- 1st Auxiliary Channel
	 * 	- 16th Auxiliary Channel
	 *
	 * Uncertain if I need to set channels to sample from, since I've set it up in the hardware design.
	 */
	Status = XSysMon_SetSeqChEnables(SysMonInstPtr, XSM_SEQ_CH_AUX04 |
													XSM_SEQ_CH_AUX05 |
													XSM_SEQ_CH_AUX06 |
													XSM_SEQ_CH_AUX07);
	if (Status != XST_SUCCESS)
	{
		return XST_FAILURE;
	}

	/*
	 * Enable end of sequence interrupt for vaux channels.
	 */
	XSysMon_IntrEnable(SysMonInstPtr, XSM_SR_EOS_MASK);

	/*
	 * Enable global interrupt of System Monitor.
	 */
	XSysMon_IntrGlobalEnable(SysMonInstPtr);

	return 0;
}

static void SysMonInterruptHandler(void *CallBackRef) {
	u32 IntrStatusValue;
	XSysMon *SysMonPtr = (XSysMon *) CallBackRef;

	/*
	 * Get the interrupt status from the device and check the value.
	 */
	IntrStatusValue = XSysMon_IntrGetStatus(SysMonPtr);

	if (IntrStatusValue & XSM_SR_EOS_MASK) {
		/*
		 * Set Temperature interrupt flag so the code
		 * in application context can be aware of this interrupt.
		 */
		eos_interrupt = TRUE;
	}

	/*
	 * Clear all bits in Interrupt Status Register.
	 */
	XSysMon_IntrClear(SysMonPtr, IntrStatusValue);
}

int SysMonSetupInterruptSystem(XIntc* IntcInstancePtr, XSysMon *SysMonPtr, u16 IntrId) {

	int Status;


	/*
	 * Connect the handler that will be called when an interrupt
	 * for the device occurs, the handler defined above performs the
	 * specific interrupt processing for the device.
	 */
	Status = XIntc_Connect(IntcInstancePtr,
				IntrId,
				(XInterruptHandler) SysMonInterruptHandler,
				SysMonPtr);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Enable the interrupt for the System Monitor/ADC device.
	 */
	XIntc_Enable(IntcInstancePtr, IntrId);

	return XST_SUCCESS;
}
